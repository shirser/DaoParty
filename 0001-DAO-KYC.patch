From 8e2bc56ca3e0a11b664dccdddee5c52c093d27e7 Mon Sep 17 00:00:00 2001
From: Shiriaev Sergei <109024976+shirser@users.noreply.github.com>
Date: Sun, 2 Feb 2025 20:42:29 +0200
Subject: [PATCH] =?UTF-8?q?=D0=9E=D0=B1=D0=BD=D0=BE=D0=B2=D0=BB=D0=B5?=
 =?UTF-8?q?=D0=BD=D0=B8=D0=B5=20=D1=84=D1=83=D0=BD=D0=BA=D1=86=D0=B8=D0=BE?=
 =?UTF-8?q?=D0=BD=D0=B0=D0=BB=D1=8C=D0=BD=D0=BE=D1=81=D1=82=D0=B8=20DAO:?=
 =?UTF-8?q?=20KYC=20=D0=B8=20=D0=BF=D1=80=D0=BE=D0=B2=D0=B5=D1=80=D0=BA?=
 =?UTF-8?q?=D0=B0=20=D0=BF=D1=80=D0=BE=D0=B2=D0=B0=D0=B9=D0=B4=D0=B5=D1=80?=
 =?UTF-8?q?=D0=BE=D0=B2?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- Добавлена функция verifyUser с дополнительными параметрами liveness и faceId, с проверками на прохождение liveness и корректность faceId.
- Обновлено событие KycUpdated: теперь оно передаёт expiry и documentType.
- Функция createProposal теперь возвращает bool.
- Добавлена возможность регистрации доверенных KYC-провайдеров (функции addKycProvider, removeKycProvider и модификатор onlyKycProvider).
- Обновлены скрипты развертывания и interact.js для взаимодействия с контрактами через доверенных KYC-провайдеров.
- Тесты (DaoParty.tests.js) обновлены для проверки новой логики верификации, отклонения некорректных параметров, истечения срока KYC, отмены и повторной верификации.
---
 0001-DAO.patch         | 309 -----------------------------------------
 contracts/DaoParty.sol |  24 +++-
 scripts/interact.js    |  17 ++-
 test/DaoParty.tests.js |  34 +++++
 4 files changed, 69 insertions(+), 315 deletions(-)
 delete mode 100644 0001-DAO.patch

diff --git a/0001-DAO.patch b/0001-DAO.patch
deleted file mode 100644
index afbf495..0000000
--- a/0001-DAO.patch
+++ /dev/null
@@ -1,309 +0,0 @@
-From 363752e2152f65236ab3d53e7a8136840811e1ba Mon Sep 17 00:00:00 2001
-From: Shiriaev Sergei <109024976+shirser@users.noreply.github.com>
-Date: Sun, 2 Feb 2025 19:31:19 +0200
-Subject: [PATCH] =?UTF-8?q?=D0=9E=D0=B1=D0=BD=D0=BE=D0=B2=D0=BB=D0=B5?=
- =?UTF-8?q?=D0=BD=D0=B8=D0=B5=20=D1=84=D1=83=D0=BD=D0=BA=D1=86=D0=B8=D0=BE?=
- =?UTF-8?q?=D0=BD=D0=B0=D0=BB=D1=8C=D0=BD=D0=BE=D1=81=D1=82=D0=B8=20DAO=20?=
- =?UTF-8?q?=D0=B8=20=D1=80=D0=B0=D0=B7=D0=B2=D0=B5=D1=80=D1=82=D1=8B=D0=B2?=
- =?UTF-8?q?=D0=B0=D0=BD=D0=B8=D1=8F?=
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-- В контракте DaoParty:
-  - Добавлена функция verifyUser с дополнительными параметрами liveness и faceId, с проверками на прохождение liveness и корректность faceId.
-  - Функция createProposal теперь возвращает bool.
-
-- Обновлены скрипты развертывания:
-  - deploy.js: теперь развертывает одновременно NFTPassport и DaoParty с логированием адресов.
-  - Добавлены deployNFTPassport.js и interact.js для развертывания и взаимодействия с контрактами.
-
-- Тесты (DaoParty.tests.js):
-  - Обновлены для проверки новой логики верификации (корректный документ, liveness, faceId) и отклонения неверных параметров.
----
- contracts/DaoParty.sol | 84 +++++++++++-------------------------------
- test/DaoParty.tests.js | 61 +++++++++++++++++++++++++-----
- 2 files changed, 73 insertions(+), 72 deletions(-)
-
-diff --git a/contracts/DaoParty.sol b/contracts/DaoParty.sol
-index 2fb80bd..850a55e 100644
---- a/contracts/DaoParty.sol
-+++ b/contracts/DaoParty.sol
-@@ -10,6 +10,12 @@ contract DaoParty is Ownable {
- 
-     // Мэппинг для хранения статуса KYC: true - верифицирован, false - не верифицирован.
-     mapping(address => bool) public kycVerified;
-+    // Хранение даты истечения KYC для каждого пользователя.
-+    mapping(address => uint256) public kycExpiry;
-+    // (Опционально) Хранение типа документа для каждого пользователя.
-+    mapping(address => string) public kycDocumentType;
-+    // Период валидности KYC (например, 30 дней = 2592000 секунд).
-+    uint256 public constant KYC_VALIDITY_PERIOD = 2592000;
- 
-     struct Proposal {
-         string description;
-@@ -25,60 +31,36 @@ contract DaoParty is Ownable {
-     event ProposalCreated(uint256 proposalId, string description, uint256 deadline);
-     event Voted(uint256 proposalId, address voter, bool support);
-     event ProposalFinalized(uint256 proposalId);
--    event KycUpdated(address indexed user, bool verified);
-+    // Обновлено событие KycUpdated: добавлен параметр documentType (можно использовать пустую строку, если не требуется)
-+    event KycUpdated(address indexed user, bool verified, uint256 expiry, string documentType);
-     event NftContractUpdated(address indexed nftAddress);
- 
--    // Передаём аргумент initialOwner базовому конструктору Ownable.
--    // Если используем последнюю версию OpenZeppelin Ownable, в которой конструктор без параметров,
--    // можно заменить на: constructor() { }
--    constructor(address initialOwner) Ownable(initialOwner) {
--        // Дополнительной логики не требуется.
--    }
-+    constructor(address initialOwner) Ownable(initialOwner) {}
- 
--    /**
--     * @dev Модификатор, проверяющий, что вызывающий адрес:
--     * 1. NFT-контракт установлен;
--     * 2. владеет хотя бы одним NFT;
--     * 3. прошёл верификацию KYC.
--     */
-     modifier onlyVerified() {
-         require(address(nftContract) != address(0), "NFT contract not set");
-         require(nftContract.balanceOf(msg.sender) > 0, "You must own an NFT");
-         require(kycVerified[msg.sender], "KYC verification required");
-+        require(kycExpiry[msg.sender] > block.timestamp, "KYC expired");
-         _;
-     }
- 
--    /**
--     * @dev Функция для установки адреса NFT-контракта.
--     * Может вызываться только владельцем.
--     * @param _nftAddress адрес NFT-контракта.
--     */
-     function setNftContract(address _nftAddress) external onlyOwner {
-         nftContract = IERC721(_nftAddress);
-         emit NftContractUpdated(_nftAddress);
-     }
- 
--    /**
--     * @dev Функция для обновления статуса KYC для пользователя.
--     * Может вызываться только владельцем.
--     * @param user адрес пользователя.
--     * @param verified true, если пользователь верифицирован, иначе false.
--     */
-     function updateKyc(address user, bool verified) external onlyOwner {
-         kycVerified[user] = verified;
--        emit KycUpdated(user, verified);
-+        if (verified) {
-+            kycExpiry[user] = block.timestamp + KYC_VALIDITY_PERIOD;
-+        } else {
-+            kycExpiry[user] = 0;
-+            kycDocumentType[user] = "";
-+        }
-+        emit KycUpdated(user, verified, kycExpiry[user], kycDocumentType[user]);
-     }
- 
--    /**
--     * @dev Верифицирует пользователя, используя документ и биометрические данные.
--     * Проверка выполняется только для внутренних паспортов РФ.
--     * Перед верификацией дополнительно проверяются параметры «живости» (liveness) и наличия корректного FaceID.
--     * Может вызываться только владельцем.
--     * @param user адрес пользователя.
--     * @param documentType строка, описывающая тип документа (требуется "ВНУТРЕННИЙ ПАСПОРТ РФ").
--     * @param liveness параметр, показывающий, что прошёл проверку на живость (true, если проверка пройдена).
--     * @param faceId строка, содержащая данные FaceID (должна быть непустой).
--     */
-     function verifyUser(
-         address user,
-         string calldata documentType,
-@@ -92,16 +74,12 @@ contract DaoParty is Ownable {
-         require(liveness, "Liveness check failed");
-         require(bytes(faceId).length > 0, "Invalid faceID");
-         kycVerified[user] = true;
--        emit KycUpdated(user, true);
-+        kycExpiry[user] = block.timestamp + KYC_VALIDITY_PERIOD;
-+        // Сохраняем тип документа
-+        kycDocumentType[user] = documentType;
-+        emit KycUpdated(user, true, kycExpiry[user], documentType);
-     }
- 
--    /**
--     * @dev Создаёт новое предложение с заданным периодом голосования.
--     * Может вызываться только верифицированными пользователями.
--     * @param description Описание предложения.
--     * @param votingPeriod Период голосования в секундах (от текущего времени).
--     * @return true, если предложение успешно создано.
--     */
-     function createProposal(string memory description, uint256 votingPeriod) external onlyVerified returns (bool) {
-         proposals.push();
-         uint256 proposalId = proposals.length - 1;
-@@ -116,12 +94,6 @@ contract DaoParty is Ownable {
-         return true;
-     }
- 
--    /**
--     * @dev Функция для голосования за предложение.
--     * Может вызываться только верифицированными пользователями.
--     * @param proposalId Идентификатор предложения.
--     * @param support true, если голос "за", false – "против".
--     */
-     function vote(uint256 proposalId, bool support) external onlyVerified {
-         require(proposalId < proposals.length, "Invalid proposal ID");
-         Proposal storage p = proposals[proposalId];
-@@ -138,11 +110,6 @@ contract DaoParty is Ownable {
-         emit Voted(proposalId, msg.sender, support);
-     }
- 
--    /**
--     * @dev Завершает голосование по предложению.
--     * Может вызываться только владельцем и только после истечения периода голосования.
--     * @param proposalId Идентификатор предложения.
--     */
-     function finalizeProposal(uint256 proposalId) external onlyOwner {
-         require(proposalId < proposals.length, "Invalid proposal ID");
-         Proposal storage p = proposals[proposalId];
-@@ -153,10 +120,6 @@ contract DaoParty is Ownable {
-         emit ProposalFinalized(proposalId);
-     }
- 
--    /**
--     * @dev Возвращает данные предложения (без поля voted).
--     * @param proposalId Идентификатор предложения.
--     */
-     function getProposal(uint256 proposalId) external view returns (
-         string memory description,
-         bool completed,
-@@ -169,11 +132,6 @@ contract DaoParty is Ownable {
-         return (p.description, p.completed, p.votesFor, p.votesAgainst, p.deadline);
-     }
- 
--    /**
--     * @dev Проверяет, голосовал ли конкретный адрес за предложение.
--     * @param proposalId Идентификатор предложения.
--     * @param voter Адрес проверяемого участника.
--     */
-     function hasVoted(uint256 proposalId, address voter) external view returns (bool) {
-         require(proposalId < proposals.length, "Invalid proposal ID");
-         Proposal storage p = proposals[proposalId];
-diff --git a/test/DaoParty.tests.js b/test/DaoParty.tests.js
-index a74d5ea..8699eec 100644
---- a/test/DaoParty.tests.js
-+++ b/test/DaoParty.tests.js
-@@ -1,10 +1,12 @@
- const { expect } = require("chai");
- const { ethers, network } = require("hardhat");
-+const { anyValue } = require("@nomicfoundation/hardhat-chai-matchers/withArgs");
- 
- describe("DaoParty (обновлённая версия с KYC и NFT, используя NFTPassport)", function () {
-   let daoParty, nftPassport;
-   let owner, verifiedUser, unverifiedUser, otherUser;
-   const votingPeriod = 3600; // 1 час
-+  const KYC_VALIDITY_PERIOD = 2592000; // 30 дней в секундах
- 
-   beforeEach(async function () {
-     [owner, verifiedUser, unverifiedUser, otherUser] = await ethers.getSigners();
-@@ -17,15 +19,18 @@ describe("DaoParty (обновлённая версия с KYC и NFT, испо
-     const nftPassportAddress = await nftPassport.getAddress();
-     console.log("NFTPassport deployed at:", nftPassportAddress);
- 
--    // Выдаем NFT для verifiedUser и при необходимости другим
-+    // Выдаем NFT для verifiedUser (при необходимости другим)
-     await nftPassport.mintPassport(verifiedUser.address);
- 
-+    // Развёртывание DaoParty
-     const DaoParty = await ethers.getContractFactory("DaoParty");
-     daoParty = await DaoParty.deploy(owner.address);
-     await daoParty.waitForDeployment();
- 
-     await daoParty.setNftContract(nftPassportAddress);
-+
-     // Верифицируем пользователя через verifyUser с корректными данными:
-+    // documentType: "ВНУТРЕННИЙ ПАСПОРТ РФ", liveness: true, faceId: "face123"
-     await daoParty.verifyUser(verifiedUser.address, "ВНУТРЕННИЙ ПАСПОРТ РФ", true, "face123");
-   });
- 
-@@ -37,15 +42,16 @@ describe("DaoParty (обновлённая версия с KYC и NFT, испо
-     });
- 
-     it("Должен позволять владельцу обновить статус KYC и выбросить событие", async function () {
-+      // При вызове updateKyc без документа тип возвращается как пустая строка ""
-       await expect(daoParty.updateKyc(unverifiedUser.address, true))
-         .to.emit(daoParty, "KycUpdated")
--        .withArgs(unverifiedUser.address, true);
-+        .withArgs(unverifiedUser.address, true, anyValue, "");
-     });
- 
-     it("Должен позволять верифицировать пользователя с корректным документом, liveness и FaceID", async function () {
-       await expect(daoParty.verifyUser(otherUser.address, "ВНУТРЕННИЙ ПАСПОРТ РФ", true, "face456"))
-         .to.emit(daoParty, "KycUpdated")
--        .withArgs(otherUser.address, true);
-+        .withArgs(otherUser.address, true, anyValue, "ВНУТРЕННИЙ ПАСПОРТ РФ");
-     });
- 
-     it("Должен отклонять верификацию пользователя с некорректным документом", async function () {
-@@ -95,6 +101,37 @@ describe("DaoParty (обновлённая версия с KYC и NFT, испо
-     });
-   });
- 
-+  describe("Механизм повторного KYC", function () {
-+    it("Должен блокировать создание предложения, если срок KYC истёк", async function () {
-+      // Обновляем KYC для verifiedUser, чтобы установить срок
-+      await daoParty.updateKyc(verifiedUser.address, true);
-+      // Увеличиваем время на больше чем KYC_VALIDITY_PERIOD (например, 30 дней + 1 секунда)
-+      await network.provider.send("evm_increaseTime", [KYC_VALIDITY_PERIOD + 1]);
-+      await network.provider.send("evm_mine");
-+      await expect(
-+        daoParty.connect(verifiedUser).createProposal("Test Proposal after KYC expiry", votingPeriod)
-+      ).to.be.revertedWith("KYC expired");
-+    });
-+
-+    it("Должен разрешать создание предложения после повторного KYC", async function () {
-+      // Обновляем KYC для verifiedUser
-+      await daoParty.updateKyc(verifiedUser.address, true);
-+      // Симулируем истечение срока KYC
-+      await network.provider.send("evm_increaseTime", [KYC_VALIDITY_PERIOD + 1]);
-+      await network.provider.send("evm_mine");
-+      // Попытка создания предложения должна отклоняться
-+      await expect(
-+        daoParty.connect(verifiedUser).createProposal("Test Proposal after KYC expiry", votingPeriod)
-+      ).to.be.revertedWith("KYC expired");
-+      // Выполняем повторное обновление KYC (периодически подтверждаем личность)
-+      await daoParty.updateKyc(verifiedUser.address, true);
-+      // Теперь создание предложения должно проходить успешно
-+      await expect(
-+        daoParty.connect(verifiedUser).createProposal("Test Proposal after KYC renewal", votingPeriod)
-+      ).to.emit(daoParty, "ProposalCreated");
-+    });
-+  });
-+
-   describe("Создание предложений и голосование", function () {
-     let proposalId;
-     beforeEach(async function () {
-@@ -107,14 +144,20 @@ describe("DaoParty (обновлённая версия с KYC и NFT, испо
-         throw new Error("ProposalCreated event not emitted");
-       }
- 
--      // Ищем событие ProposalCreated по имени
--      const event = receipt.logs.find(e => e.fragment && e.fragment.name === "ProposalCreated");
--      if (!event) {
-+      const parsedEvents = receipt.logs
-+        .map((log) => {
-+          try {
-+            return daoParty.interface.parseLog(log);
-+          } catch (e) {
-+            return null;
-+          }
-+        })
-+        .filter((e) => e && e.name === "ProposalCreated");
-+
-+      if (parsedEvents.length === 0) {
-         throw new Error("ProposalCreated event not found in transaction");
-       }
--
--      // Используем Number(event.args[0]) вместо .toNumber()
--      proposalId = Number(event.args[0]);
-+      proposalId = Number(parsedEvents[0].args[0].toString());
-     });
- 
-     it("Должно создавать предложение с корректным дедлайном", async function () {
--- 
-2.37.1 (Apple Git-137.1)
-
diff --git a/contracts/DaoParty.sol b/contracts/DaoParty.sol
index ffa0122..422a5bd 100644
--- a/contracts/DaoParty.sol
+++ b/contracts/DaoParty.sol
@@ -17,6 +17,27 @@ contract DaoParty is Ownable {
     // Период валидности KYC (например, 30 дней = 2592000 секунд).
     uint256 public constant KYC_VALIDITY_PERIOD = 2592000;
 
+    // --- Новый функционал для доверенных KYC-провайдеров ---
+    // Мэппинг доверенных KYC-провайдеров.
+    mapping(address => bool) public kycProviders;
+
+    // Модификатор, разрешающий вызов только владельцу или доверенным KYC-провайдерам.
+    modifier onlyKycProvider() {
+        require(kycProviders[msg.sender] || msg.sender == owner(), "Not an authorized KYC provider");
+        _;
+    }
+
+    // Функция для добавления доверенного KYC-провайдера. Вызывается только владельцем.
+    function addKycProvider(address provider) external onlyOwner {
+        kycProviders[provider] = true;
+    }
+
+    // Функция для удаления доверенного KYC-провайдера. Вызывается только владельцем.
+    function removeKycProvider(address provider) external onlyOwner {
+        kycProviders[provider] = false;
+    }
+    // -----------------------------------------------
+
     struct Proposal {
         string description;
         bool completed;
@@ -63,12 +84,13 @@ contract DaoParty is Ownable {
         emit KycUpdated(user, verified, kycExpiry[user], kycDocumentType[user]);
     }
 
+    // Функция verifyUser теперь доступна доверенным KYC-провайдерам (или владельцу)
     function verifyUser(
         address user,
         string calldata documentType,
         bool liveness,
         string calldata faceId
-    ) external onlyOwner {
+    ) external onlyKycProvider {
         require(
             keccak256(bytes(documentType)) == keccak256(bytes(unicode"ВНУТРЕННИЙ ПАСПОРТ РФ")),
             "Only Russian internal passports are allowed"
diff --git a/scripts/interact.js b/scripts/interact.js
index 6568a07..922e791 100644
--- a/scripts/interact.js
+++ b/scripts/interact.js
@@ -35,7 +35,7 @@ async function main() {
 
   // Получаем инстанс контракта NFTPassport, используя переданный адрес
   const NFTPassport = await ethers.getContractFactory("NFTPassport");
-  const nftPassport = NFTPassport.attach(nftPassportAddress);
+  const nftPassport = await NFTPassport.attach(nftPassportAddress);
   console.log("Взаимодействуем с контрактом NFTPassport, адрес:", nftPassportAddress);
 
   // --- Административные функции ---
@@ -47,6 +47,12 @@ async function main() {
   await tx.wait();
   console.log("NFT-контракт установлен на:", nftPassportAddress);
 
+  // Регистрируем доверенного KYC-провайдера (например, user1)
+  console.log("\n[Администрирование] Регистрируем доверенного KYC-провайдера (user1)...");
+  tx = await daoParty.addKycProvider(user1.address);
+  await tx.wait();
+  console.log("User1 добавлен как доверенный KYC-провайдер.");
+
   // Минтим NFT для user3, чтобы он владел NFT и мог создавать предложения.
   console.log("\n[Администрирование] Минтим NFT для user3...");
   tx = await nftPassport.mintPassport(user3.address);
@@ -61,8 +67,9 @@ async function main() {
 
   // Верифицируем user3 через verifyUser с корректными параметрами:
   // documentType: "ВНУТРЕННИЙ ПАСПОРТ РФ", liveness: true, faceId: "faceXYZ"
-  console.log("\n[Администрирование] Верификация user3 с корректными данными...");
-  tx = await daoParty.verifyUser(user3.address, "ВНУТРЕННИЙ ПАСПОРТ РФ", true, "faceXYZ");
+  // Вызываем verifyUser от имени доверенного провайдера (user1)
+  console.log("\n[Администрирование] Верификация user3 с корректными данными от доверенного провайдера...");
+  tx = await daoParty.connect(user1).verifyUser(user3.address, "ВНУТРЕННИЙ ПАСПОРТ РФ", true, "faceXYZ");
   await tx.wait();
   console.log("User3 успешно верифицирован.");
 
@@ -85,8 +92,8 @@ async function main() {
   }
 
   // 3. Повторная верификация user3 для восстановления возможности создания предложения
-  console.log("\n[Проверка KYC] Повторная верификация user3...");
-  tx = await daoParty.verifyUser(user3.address, "ВНУТРЕННИЙ ПАСПОРТ РФ", true, "faceXYZ");
+  console.log("\n[Проверка KYC] Повторная верификация user3 от доверенного провайдера...");
+  tx = await daoParty.connect(user1).verifyUser(user3.address, "ВНУТРЕННИЙ ПАСПОРТ РФ", true, "faceXYZ");
   await tx.wait();
   console.log("User3 успешно повторно верифицирован.");
 
diff --git a/test/DaoParty.tests.js b/test/DaoParty.tests.js
index 12617ce..5e5a867 100644
--- a/test/DaoParty.tests.js
+++ b/test/DaoParty.tests.js
@@ -281,6 +281,40 @@ describe("DaoParty (обновлённая версия с KYC и NFT, испо
         });
     });
 
+    describe("Ограничения KYC", function () {
+        it("Не должен разрешать повторную верификацию в течение 12 месяцев", async function () {
+            // verifiedUser уже верифицирован в beforeEach через verifyUser с faceId "face123"
+            // Попытаемся повторно верифицировать verifiedUser с другим паспортом до истечения 12 месяцев.
+            await expect(
+                daoParty.verifyUser(verifiedUser.address, "ВНУТРЕННИЙ ПАСПОРТ РФ", true, "faceNew")
+            ).to.be.revertedWith("KYC can be updated only once per 12 months");
+        });
+
+        it("Не должен позволять использовать один и тот же паспорт (faceId) для верификации другого пользователя", async function () {
+            // verifiedUser уже прошёл верификацию с faceId "face123"
+            // Попытаемся верифицировать otherUser с тем же faceId "face123"
+            await expect(
+                daoParty.verifyUser(otherUser.address, "ВНУТРЕННИЙ ПАСПОРТ РФ", true, "face123")
+            ).to.be.revertedWith("Passport already used");
+        });
+
+        it("Должен разрешать повторную верификацию спустя 12 месяцев", async function () {
+            // Отменяем KYC для verifiedUser
+            await daoParty.connect(verifiedUser).cancelKyc();
+
+            // Увеличиваем время на 365 дней + 1 секунда, чтобы пройти ограничение по частоте
+            await network.provider.send("evm_increaseTime", [365 * 24 * 3600 + 1]);
+            await network.provider.send("evm_mine");
+
+            // Теперь повторная верификация должна пройти успешно
+            await expect(
+                    daoParty.verifyUser(verifiedUser.address, "ВНУТРЕННИЙ ПАСПОРТ РФ", true, "faceNew")
+                ).to.emit(daoParty, "KycUpdated")
+                .withArgs(verifiedUser.address, true, anyValue, "ВНУТРЕННИЙ ПАСПОРТ РФ");
+        });
+    });
+
+
     describe("Финализация предложений", function () {
         let proposalId;
         beforeEach(async function () {
-- 
2.37.1 (Apple Git-137.1)

